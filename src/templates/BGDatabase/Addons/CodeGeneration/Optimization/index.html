#set page=Code Generation Addon
#set subPage=Optimization

<h4>Description</h4>
<p>
    This article describes available optimization settings for CodeGen addon.
    The classes, generated by <a href="..">CodeGen addon</a> and <a href="../../../CodeGeneration/MonoBehaviourClasses">MonoBehaviour code generator</a>
    gain performance boost while using these settings, so if these classes is your main API for accessing database, we highly recommend to use all optimization parameters.
    If you want generated MonoBehaviour classes to also benefit from these parameters,
    enable them and toggle on "Use CodeGen addon generated classes" parameter in MonoBehaviour generator settings and re-generate the classes.
</p>

<h5>Generate metas</h5>
<p>
    Additional classes for tables (metas) are generated.
    This eliminates the need for down-casting rows (entities).
    This parameter is required for some other settings.
</p>

<h5>Storage</h5>
<p>
    The most important setting. It defines where cell values are stored and improve getters and <a href="#rawSetters">raw
    setters</a> performance
</p>
<ol>
    <li><code>Default</code> - cell values for most fields are stored in an array within the field class. (slower)</li>
    <li><code>GeneratedClasses</code> - cell values for some fields are stored in generated class (faster). Additional
        classes for fields are generated
    </li>
</ol>
<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenExtensionClasses6.png"><img style="width:400px; height: 200px"
                                                                        src="#path images/BGDatabase/CodeGenExtensionClasses6.png"></a>
</div>
<p>
    To ensure that the generated classes for the database fields are being used in the database,
    navigate to 'Configuration -> $TableName' and check the 'Type & Class' column.
    If the generated classes are used, an asterisk will be added next to the field type.
</p>
<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenExtensionClasses7.png"><img style="width:400px; height: 200px"
                                                                        src="#path images/BGDatabase/CodeGenExtensionClasses7.png"></a>
</div>

Current status of fields (as of v.1.9.1):
<ol>
    <li>Currently supported: primitive, Unity primitive, enums, relationSingle/relationMultiple/viewRelationSingle</li>
    <li>Not supported yet: lists, nullable, strings</li>
    <li>The following types will not be supported for a good reason: assets, calculated fields.</li>
</ol>

<h5>Cache relation values</h5>
<p>
    Caching relation field values in generated classes can significantly improve the performance of getter methods.
    This setting is ideal for scenarios with frequent reads and infrequent writes.
    The memory cost for
</p>
<ol>
    <li>Single row relations is 9 bytes per row (1 byte for the dirty flag + pointer to the row)</li>
    <li>Multiple rows relation depends on value size (1 byte for the dirty flag + an additional list for the value)</li>
</ol>
<p>
    Important note regarding caching a List (relationMultiple) values
</p>
<ol>
    <li>Values can not be null anymore, if there is no value an empty list will be returned</li>
    <li>There is no need to use FillXXX methods to get rid of GC overhead (except for values in <a
            href="../../../CodeGeneration/ExtensionClasses#reverse">the reverse direction</a>)
    </li>
    <li>When you read the value, a List object is returned, which is utilized to store the cached value.
        If you modify this list, you must pass it back to the setter, otherwise data integrity may be compromised.
        <pre class="nomargin"><code class="language-csharp">        var list = entity.someList;
        list.Add(SomeTable.GetEntity(0)); // <- this call modifies the cached value, not the database value
        entity.someList = list; // <- this call is very important</code></pre>
    </li>
</ol>

<h5>Other relations optimizations</h5>
<p>A new setting has been added to relational fields, called <code>Ignore list order</code>. Use it for:
</p>
<ol>
    <li>Nested fields, if the order of nested rows is not important.</li>
    <li>Other relational fields, if the order of rows returned while traversing the relation in reverse is not
        important.
    </li>
</ol>

<h5>Runtime initialization</h5>
<p>
    This parameter defines how generated classes fields are initialized
</p>
<ol>
    <li><code>On Demand</code> - the C# fields for database tables and fields are initialized on demand (slow)
    </li>
    <li><code>Manual</code> - you need to initialize runtime manually by calling
        <code>BGCodeGenRuntimeInitializer.InitializeCodeGenRuntime</code> method (faster).
        You need to call <code>BGCodeGenRuntimeInitializer.InitializeCodeGenRuntime();</code> method
        before accessing database and after loading the game with the <a href="../../SaveLoad">SaveLoad addon</a>
        if "Reload database" parameter is used.
        If the <code>BGCodeGenRuntimeInitializer.InitializeCodeGenRuntime</code> method is not called,
        a NullReferenceException will be thrown on database access via generated classes.
    </li>
</ol>


<h5 id="rawSetters">Raw setters</h5>
<p>
    Raw setters are additional properties that allow you to set values while bypassing events.
    Regular setters are slower due to the additional event dispatching.
    If you do not need events to be triggered, you can use faster setters to improve performance.
    Raw setters are generated for some fields (like primitive fields) only if the fields are not included into keys or
    indexes
</p>

<h5>Garbage Collection overhead</h5>
<p>
    Some methods can have heap memory allocation, producing GC overhead.
    If you call these methods during a rare event, such as scene loading, the impact is negligible.
    However, if you call them in a hot loop, for example, in the Update or FixedUpdate methods, you may want to ensure that
    no heap memory is allocated. In most cases, using a reusable list solves the problem.
</p>
<table class="contentTable">
    <tr>
        <th>
            #
        </th>
        <th>
            Method
        </th>
        <th>
            Solution
        </th>
    </tr>
    <tr>
        <td>1</td>
        <td>FindEntities method</td>
        <td>Use corresponding FillXXX method and pass a reusable list to this method.
            <details>
                <summary>Code example</summary>
                <pre class="nomargin"><code class="language-csharp">using System.Collections.Generic;
public class Temp : UnityEngine.MonoBehaviour
{
    private static readonly List&lt;D_Temp&gt; reusableList = new List&lt;D_Temp&gt;();

    private void Update()
    {
        // List&lt;D_Temp&gt; entity = D_Temp.FindEntities(entity => entity.intField > 0);// <- produce garbage
        D_Temp.FindEntities(entity => entity.intField > 0, reusableList); // <- no garbage
    }
}</code></pre>
            </details>
        </td>
    </tr>
    <tr>
        <td>2</td>
        <td>nested field getter</td>
        <td>The same as #1 (FillXXX method)
            <details>
                <summary>Code example</summary>
                <pre class="nomargin"><code class="language-csharp">using System.Collections.Generic;

public class Temp : UnityEngine.MonoBehaviour
{
    private static readonly List&lt;D_nested&gt; reusableList = new List&lt;D_nested&lt;();

    private void Update()
    {
        var entity = D_Temp.GetEntity(0);
        //List&lt;D_nested&lt; nestedRows = entity.nested; // <- produce garbage
        entity.Fillnested(reusableList); // <- no garbage
    }
}</code></pre>
            </details>
        </td>
    </tr>
    <tr>
        <td>3</td>
        <td>The getters for relations with List value (relationMultiple / viewRelationMultiple)</td>
        <td>
            <ol>Option #1: The same as #1 (FillXXX method)</ol>
            <ol>Option #2: Use "cache relation value" optimization parameter.
                Note, it has some memory cost (the same as using non-static reusable list, added to the generated class)
            </ol>
            <details>
                <summary>Code example for option #1</summary>
                <pre class="nomargin"><code class="language-csharp">using System.Collections.Generic;
public class Temp : UnityEngine.MonoBehaviour
{
    private static readonly List&lt;D_Related1&gt; reusableList = new List&lt;D_Related1&gt;();

    private void Update()
    {
        D_Temp entity = D_Temp.GetEntity(0);
        // List&lt;D_Related1&gt; result = entity.mRel; // <- produce garbage
        entity.FillmRel(reusableList); // <- no garbage
    }
}</code></pre>
            </details>
        </td>
    </tr>
    <tr>
        <td>4</td>
        <td>The getters for List values while traversing relations in reverse direction</td>
        <td>The same as #1 (FillXXX method)
            <details>
                <summary>Code example for option #1</summary>
                <pre class="nomargin"><code class="language-csharp">using System.Collections.Generic;
public class Temp : UnityEngine.MonoBehaviour
{
    private static readonly List&lt;D_Temp&gt; reusableList = new List&lt;D_Temp&gt;();

    private void Update()
    {
        D_Related1 entity = D_Related1.GetEntity(0);
        // List&lt;D_Temp&gt; result = entity.RelatedTempListUsingsRelRelation; // <- produce garbage
        entity.FillRelatedTempListUsingsRelRelation(reusableList); // <- no garbage
    }
}</code></pre>
            </details>
        </td>
    </tr>
</table>
<p>
    Important note: You can add reusable lists <a href="../../../Misc/AddingMembersToGeneratedClasses">directly to the generated class</a>
    and include your own getters and setters that do not produce garbage. For example
</p>
<details>
    <summary>Adding your own members to generated class</summary>
    <pre class="nomargin"><code class="language-csharp">using System.Collections.Generic;
//BansheeGz.BGDatabase.Example is the namespace of generated class
namespace BansheeGz.BGDatabase.Example
{
    //BGE_AllFields is the name of generated class
    partial class BGE_AllFields
    {
        //reusable list for enumList field
        private static readonly List&lt;BGUtilForTest.TestEnumInt&gt; reusableEnumList = new();

        //property without GC
        public List&lt;BGUtilForTest.TestEnumInt&gt; enumListNoGC
        {
            get
            {
                Fillf_enumList(reusableEnumList);
                return reusableEnumList;
            }
        }
    }
}</code></pre>
</details>
<p>Keeping a list static is much more memory efficient, but you need to remember that
    it can only contain the result for the last row for which the property is called. You can make it non-static if you prefer.
</p>


<h5>Events degrade performance</h5>
<p>
    Database events can have negative impact on setter methods performance. If you can do without events, don't use
    them.
</p>

<h5>"Slow" fields to be aware of</h5>
<table class="contentTable">
    <tr>
        <th>
            Field
        </th>
        <th>
            Description
        </th>
    </tr>
    <tr>
        <td>asset fields</td>
        <td>Reading a value also involves loading an asset. Loading the asset for the first time can be slow.
            Use Addressables with asynchronous loading for such fields.
        </td>
    </tr>
    <tr>
        <td>calculated fields</td>
        <td>Try to not read the values of such fields in hot loops.
            Replace them with programmable fields or <a href="../../../Misc/AddingMembersToGeneratedClasses">custom C#
                properties</a>
        </td>
    </tr>
    <tr>
        <td>relation fields</td>
        <td>
            These are the most troublesome fields.
            Caching the values for such fields should resolve the problem with slow getters in "frequent reads and
            infrequent writes" scenarios,
            however the setters can still be relatively slow especially in some scenarios (be very careful to use
            relation field setters in hot loops)
        </td>
    </tr>
</table>

<h5>Conclusion</h5>
<p>Test your game's performance before releasing it using the minimal required hardware.
    Contact us if you encounter performance issues with our asset.
</p>