#set page=Code Generation (MonoBehaviour classes)

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=cs&amp;skin=desert"></script>

<h4>Description</h4>
<p>
    Main purpose of these classes- is to be added as components to GameObjects, thus hooking these GameObjects to table's rows.
</p>

<p>
    These classes are Unity standard components and can be added to any GameObject in the Inspector.
    After you added one of such classes to GameObject, you can chose which row should be connected,
    the correct table(meta) will be automatically selected
</p>
<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenMonoBehaviour1.png"><img style="width: 400px" src="#path images/BGDatabase/CodeGenMonoBehaviour1.png"></a>
</div>


<h4>Difference from BGEntityGo</h4>
<p>
    Without these classes you would use generic BGEntityGo component to hook up GameObject to database.
</p>
<p>
    So, what is the difference between BGEntityGo and generated class?
</p>
<ol>
    <li>You don't have to chose meta- it'll be automatically chosen</li>
    <li>Instead of using basic API for accessing fields like this: <code>var intValue = Get&lt;int&gt;("intField");</code>
        you have additional property generated for each field, so you can use code like this <code>var intValue = intField;</code> </li>
    <li>Additionally, you can chose to use classes, generated by ExtensionClasses generator, so you can easily navigate by relational fields.
        More information about it below.
    </li>
</ol>

<h4 id="explanation">Using classes, generated by ExtensionClasses</h4>
<p>
    Question: why bother to use those classes? Answer: because of relational fields.
</p>
<p>
    There are 3 fields in BGDatabase, that are relations (relationSingle,relationMultiple and nested).
    As a value they return the reference(s) to another row(s) (BGEntity).
</p>
<p>
    Here is the simple example: Table1 has a relationSingle field called Relation, that points to a row from Table2.
</p>
<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenMonoBehaviour2.png"><img style="width: 400px" src="#path images/BGDatabase/CodeGenMonoBehaviour2.png"></a>
</div>
<p>
    Without using ExtensionClasses you can access Relation field value with such code
</p>
<pre class="cs">
    BGEntity t2Value = t1.Relation;
</pre>
<p>
    So, if t1 - is first row of Table1, t2Value will be a first row of Table2, However it's type - is basic type: BGEntity.
    So you can access Table2.intField only with basic API like so: <code>t2Value.Get&lt;int&gt;("intField")</code>
</p>
<p>
    That is certainly not what we want. So using ExtensionClasses makes relational value to be casted to be the type, generated by ExtensionClasses
    , e.g.
</p>
<pre class="cs">
    Table2 t2Value = t1.Relation;
    var intValue = t2Value.intField;
</pre>

<h4>How to generate</h4>
<ol>
    <li>Open BGDatabase window from Unity menu <code>Window->BGDatabase</code></li>
    <li>Chose <code>Settings->CodeGen</code></li>
    <li>Fill in <a href="#parameters">parameters</a> and press <code>Generate</code> button</li>
</ol>
<div class="importantNote">
    Once you chose your naming scheme (<b>Classes name prefix</b>), generated the classes(components)
    and attached them to GameObjects, you should not change this setting,
    otherwise the references to these components will be lost. The same applies to tables names.
</div>
<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenMonoBehaviour3.png"><img style="width: 400px" src="#path images/BGDatabase/CodeGenMonoBehaviour3.png"></a>
</div>

<h4 id="parameters">Parameters</h4>
<table class="contentTable">
    <tr>
        <th>
            Parameter name
        </th>
        <th>
            Description
        </th>
    </tr>
    <tr>
        <td>Code Generator</td>
        <td>Class to use for code generation (use default one)</td>
    </tr>
    <tr>
        <td>Source Folder</td>
        <td>The folder to place generated C# classes (components) to. The folder must be inside you project</td>
    </tr>
    <tr>
        <td>Package</td>
        <td>Package (C# namespace) for generated classes. For example <code>MySpace</code>. You can safely leave this setting blank.</td>
    </tr>
    <tr>
        <td>Class names prefix</td>
        <td>
            Prefix to use for each class name.
            So if you use <code>M_</code> prefix, the final class for <code>MyTable</code> table will be named <code>M_MyTable</code>.
            We have multiple code generators, so using different prefixes for different code generators helps to differentiate generated classes and avoid naming collisions
        </td>
    </tr>
    <tr>
        <td>Field names prefix</td>
        <td>
            Prefix to use for each generated property name.
            So if you use <code>f_</code> prefix, the final name for <code>intField</code> field will be <code>f_intField</code>.
            You can safely leave this setting blank.
        </td>
    </tr>
    <tr>
        <td>Use classes, generated by CodeGen addon</td>
        <td>
            Turn it on if you use <a href="../../Addons/CodeGeneration">CodeGen addon</a>. <a href="#explanation">More information</a> about this setting
        </td>
    </tr>
</table>

<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenMonoBehaviour4.png"><img style="width: 400px" src="#path images/BGDatabase/CodeGenMonoBehaviour4.png"></a>
</div>



