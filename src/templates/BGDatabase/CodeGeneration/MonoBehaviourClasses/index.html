#set page=Code Generation (MonoBehaviour classes)

<h4>Description</h4>
<p>
    Main purpose of these classes - is to be added as components to GameObjects, thus connecting these GameObjects to table's rows.
</p>

<p>
    These classes are Unity standard components and can be added to any GameObject in the Inspector.
    After you added one of such classes to GameObject, you can choose which row should be connected,
    the correct table(meta) will be automatically selected
</p>
<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenMonoBehaviour1.png"><img style="width: 400px" src="#path images/BGDatabase/CodeGenMonoBehaviour1.png"></a>
</div>

<h4>Performance boost</h4>
<p>
    Generated classes can gain performance boost from using <a href="../../Addons/CodeGeneration">CodeGen addon</a> with
    <a href="../../Addons/CodeGeneration/Optimization">optimization parameters</a> and with "Using CodeGen addon classes" parameter on.
</p>

<h4>Alternatives</h4>
<p>
    Using these components is not the only option to create a serializable reference to the database row.
    For other alternatives, read this section <a href="../../Misc/SerializableReferences">Referencing tables, fields, rows and cells from your own MonoBehaviour scripts</a>
</p>

<h4>Difference from BGEntityGo</h4>
<p>
    Without these classes you would use generic BGEntityGo component to hook up GameObject to database.
</p>
<p>
    So, what is the difference between BGEntityGo and generated class?
</p>
<ol>
    <li>You don't have to choose a meta- it'll be automatically chosen</li>
    <li>Instead of using basic API for accessing fields like this: <code>var intValue = Get&lt;int&gt;("intField");</code>
        you have additional property generated for each field, so you can use code like this <code>var intValue = intField;</code> </li>
    <li>Additionally, you can choose to use classes, generated by ExtensionClasses generator, so you can easily navigate by relational fields
        and take advantage of performance optimization.
        More information about it below.
    </li>
</ol>

<h4 id="explanation">Using classes, generated by ExtensionClasses</h4>
<p>
    A question: why bother to use those classes? The answer is 1) the relational fields 2) code optimization.
</p>
<h5>1) The relational fields</h5>
<p>
    There are 5 fields in BGDatabase, that are relations (relationSingle,relationMultiple, nested, viewRelationSingle, viewRelationMultiple).
    As a value they return the reference(s) to another row(s) (BGEntity).
</p>
<p>
    Here is the simple example: Table1 has a relationSingle field called Relation, that points to a row from Table2.
</p>
<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenMonoBehaviour2.png"><img style="width: 400px" src="#path images/BGDatabase/CodeGenMonoBehaviour2.png"></a>
</div>
<p>
    Without using ExtensionClasses you can access Relation field value with such code
</p>
<pre class="nomargin"><code class="language-csharp">    BGEntity t2Value = t1.Relation;</code></pre>
<p>
    So, if t1 - is first row of Table1, t2Value will be a first row of Table2, However it's type - is basic type: BGEntity.
    So you can access Table2.intField only with basic API like so: <code>t2Value.Get&lt;int&gt;("intField")</code>
</p>
<p>
    That is certainly not what we want. So using ExtensionClasses makes relational value to be cast to be the type, generated by ExtensionClasses
    , e.g.
</p>
<pre class="nomargin"><code class="language-csharp">    Table2 t2Value = t1.Relation;
    var intValue = t2Value.intField;</code></pre>

<h5>2) code optimization</h5>
<p>Starting with BGDatabase 1.9.1 there is <a href="../../Addons/CodeGeneration/Optimization">an option</a> to optimize CodeGen runtime.
    MonoBehaviour code generator can take advantage of this optimization. You need to enable optimization parameters in CodeGen addon settings and toggle on
    "Use classes, generated by CodeGen addon" parameter in MonoBehaviour code generator settings.
</p>

<h4>How to generate</h4>
<ol>
    <li>Open BGDatabase window from Unity menu <code>Window->BGDatabase</code></li>
    <li>Choose <code>Settings->CodeGen</code></li>
    <li>Fill in <a href="#parameters">parameters</a> and press <code>Generate</code> button</li>
</ol>
<div class="importantNote">
    Once you chose your naming scheme (<b>Classes name prefix</b>), generated the classes(components)
    and attached them to GameObjects, you should not change this setting,
    otherwise the references to these components will be lost. The same applies to tables names.
</div>
<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenMonoBehaviour3.png"><img style="width: 400px" src="#path images/BGDatabase/CodeGenMonoBehaviour3.png"></a>
</div>

<h4 id="whatIsGenerated">What is generated, exactly?</h4>
<p>
    We will use MyTable as a table name (generated class name) and 2 fields (name string, gold int) for illustration purpose.
</p>
<table class="contentTable">
    <tr>
        <th>
            Method/property name
        </th>
        <th>
            Static
        </th>
        <th>
            Description
        </th>
    </tr>
    <tr>
        <td>{field_prefix}{FieldName}</td>
        <td>No</td>
        <td>Properties are generated for each table field.
            Each property has the same type as corresponding database field.
            Use these properties to read/write values from/to database
        </td>
    </tr>
    <tr>
        <td>MetaDefault</td>
        <td>Yes</td>
        <td>
            Use this property to get access to the table (<a href="../../API/BGMetaEntity">BGMetaEntity</a> class)
        </td>
    </tr>
    <tr>
        <td>_{field_prefix}{FieldName}</td>
        <td>Yes</td>
        <td>
            Use this property to get access to the field (column) (<a href="../../API/BGField">BGField</a> class)
        </td>
    </tr>
    <tr>
        <td>Related {MetaName} ListUsing {RelationName} Relation</td>
        <td>No</td>
        <td>
            For each incoming relation a property is generated for traversing relation in reverse direction.
        </td>
    </tr>
</table>

<h4 id="parameters">Parameters</h4>
<table class="contentTable">
    <tr>
        <th>
            Parameter name
        </th>
        <th>
            Description
        </th>
    </tr>
    <tr>
        <td>Code Generator</td>
        <td>Class to use for code generation (use default one)</td>
    </tr>
    <tr>
        <td>Source Folder</td>
        <td>The folder to place generated C# classes (components) to. The folder must be inside you project</td>
    </tr>
    <tr>
        <td>Package</td>
        <td>Package (C# namespace) for generated classes. For example <code>MySpace</code>. You can safely leave this setting blank.</td>
    </tr>
    <tr>
        <td>Class names prefix</td>
        <td>
            Prefix to use for each class name.
            So if you use <code>M_</code> prefix, the final class for <code>MyTable</code> table will be named <code>M_MyTable</code>.
            We have multiple code generators, so using different prefixes for different code generators helps to differentiate generated classes and avoid naming collisions
        </td>
    </tr>
    <tr>
        <td>Field names prefix</td>
        <td>
            Prefix to use for each generated property name.
            So if you use <code>f_</code> prefix, the final name for <code>intField</code> field will be <code>f_intField</code>.
            You can safely leave this setting blank.
        </td>
    </tr>
    <tr>
        <td>Use classes, generated by CodeGen addon</td>
        <td>
            Turn it on if you use <a href="../../Addons/CodeGeneration">CodeGen addon</a>. <a href="#explanation">More information</a> about this setting
        </td>
    </tr>
</table>

<div class="bg-image">
    <a href="#path images/BGDatabase/CodeGenMonoBehaviour4.png"><img style="width: 400px" src="#path images/BGDatabase/CodeGenMonoBehaviour4.png"></a>
</div>



