#set page=Misc

<h4>Table of content</h4>
<div>
    <ol>
        <li><a href="#editor">Editor assembly</a></li>
        <li><a href="#events">Events</a></li>
        <li><a href="#validation">Validation</a></li>
        <li><a href="#keys">Keys and indexes</a></li>
        <li><a href="#commandline">Command line</a></li>
        <li><a href="#customFields">Custom fields</a></li>
    </ol>
</div>

<h4 id="editor">Editor assembly</h4>

<p>
    Mostly, database works inside Editor assembly the same way as it works at runtime, meaning you can develop your own Editor tools on top of the database
</p>
<p>
    Use generated classes to access database. To save database in Editor via C# code, use this call:
</p>
<pre class="nomargin"><code class="language-csharp">
    BansheeGz.BGDatabase.Editor.BGRepoSaver.SaveRepo();
</code></pre>
<p>
    To assign unity asset field values, use SetAsset method, defined on each unity asset field and available in Editor assembly (this method is not available at runtime assembly)
</p>
<pre class="nomargin"><code class="language-csharp">
    SetAsset(int entityIndex, UnityEngine.Object asset)
</code></pre>


<h4 id="events">Events</h4>

<p>
    Events let use listen to database changes, like changing the field or entity, adding or removing entities. Make sure
</p>
<ol>
    <li>To pair adding a listener with removing a listener to prevent memory leaks</li>
    <li>all events handlers have try/catch block to <a href="https://stackoverflow.com/a/8745599">prevent exception being fired from event handlers</a></li>
</ol>
<p>
    Following events are available:
</p>
<table class="contentTable">
    <tr>
        <th width="20%">
            Event
        </th>
        <th>
            Description
        </th>
    </tr>
    <tr>
        <td>Field value changed</td>
        <td>It is fired when provided field value change (any entity)</td>
    </tr>
    <tr>
        <td>Entity is updated</td>
        <td>It is fired when provided entity value change (any field)</td>
    </tr>
    <tr>
        <td>Entity is deleted</td>
        <td>It is fired when provided entity deleted</td>
    </tr>
    <tr>
        <td>Any entity is updated</td>
        <td>It is fired when any entity updated (any field)</td>
    </tr>
    <tr>
        <td>Any entity is added</td>
        <td>It is fired when new entity is added</td>
    </tr>
    <tr>
        <td>Any entity is deleted</td>
        <td>It is fired when any entity deleted</td>
    </tr>
    <tr>
        <td>Before any entity deleted</td>
        <td>It is fired before any entity is deleted</td>
    </tr>
    <tr>
        <td>Batch update event</td>
        <td>Batch update event is fired when BGRepo.I.Events.Batch(Action action); method is used.
            When this method is used, no individual events will be fired while action is being executed
            and one single batch event will be fired when action is executed.
            This is required for performance's sake when massive changes to database should be done without firing individual events
        </td>
    </tr>
    <tr>
        <td>Any change event</td>
        <td>It is fired on any database change </td>
    </tr>
</table>
<p>
    For usage example, see this <a href="../Downloads/EventListenersDemo.txt">demo C# script</a>
</p>



<h4 id="validation">Validation</h4>

<p>
    Data validation allows to set the rules to validate data.
    Validation works in Unity Editor only and has no effect at runtime.
    To turn on validation, press on "Validation off" button at the top left of BGDatabase window.
</p>

<h6>Validation types</h6>
<ol>
    <li><a href="#data">Database data validation</a></li>
    <li><a href="#scene">Scene objects validation</a> (Binders and BGEntityGo components)</li>
</ol>

<h6 id="data">Database data validation</h6>
<table class="contentTable">
    <tr>
        <th>
            Validation rule
        </th>
        <th>
            Description
        </th>
    </tr>
    <tr>
        <td>Entity name is unique</td>
        <td>If entity has a name, it should be unique</td>
    </tr>
    <tr>
        <td>Entity name is empty</td>
        <td>Entities should have no name (names can be cleared under Configuration tab)</td>
    </tr>
    <tr>
        <td>Entity is singleton</td>
        <td>Only one single entity should exist</td>
    </tr>
    <tr>
        <td>Field is required</td>
        <td>Field should have some value. Only class-based fields are affected, cause struct-based fields always have a value</td>
    </tr>
    <tr>
        <td>Key is unique</td>
        <td>Each <a href="#keys">key</a>, marked as unique, should have 0-1 matching rows. If there are more than 1 matching row, it's considered to be a rule violation.</td>
    </tr>
</table>
<p>
    To review validation log, hover over red E icons as shown on the screenshot below.
    E icon is shown only if at least one error exists.
</p>
<div class="bg-image">
    <a href="#path images/BGDatabase/Validation1.png"><img style="width: 400px" src="#path images/BGDatabase/Validation1.png"></a>
</div>

<h6  id="scene">Scene objects validation</h6>
<p>
    Following BGDatabase scene components can also be validated (using Scene Explorer tab).
</p>
<ol>
    <li>BGEntityGo components</li>
    <li>Generated Monobehaviour classes (extending from BGEntityGo)</li>
    <li><a href="../DataBinding">Data binders</a></li>
</ol>
<p>
    Any component, which has an error, will be highlighted.
</p>


<h4 id="keys">Keys and indexes</h4>
<ol>
    <li>Key consist of 1-n fields and can be used to look up row(s) quickly.
        It also can be used in rows <a href="#validation">validation</a>
    </li>
    <li>
        Index has a reference to a single field and can be used for effective range scan
    </li>
</ol>
<p>
    Here is a table, comparing different row(s) retrieval methods efficiency
</p>
<table class="contentTable dTable">
    <tr>
        <th>Method</th>
        <th>Underlying structure</th>
        <th>Time complexity</th>
        <th>Comments</th>
    </tr>
    <tr>
        <td>meta.GetEntity(int index)</td>
        <td>list</td>
        <td>O(1)</td>
        <td>fastest method</td>
    </tr>
    <tr>
        <td>meta.GetEntity(BGId Id)</td>
        <td>hashtable</td>
        <td>O(1)</td>
        <td></td>
    </tr>
    <tr>
        <td>GetEntity(string name)</td>
        <td>hashtable</td>
        <td>O(1)</td>
        <td>if name field data is not <a href="https://stackoverflow.com/a/35516532" target="_blank">skewed</a></td>
    </tr>
    <tr>
        <td>key.GetEntityByKey(params object[] keys)</td>
        <td>hashtable</td>
        <td>O(1)</td>
        <td>if key's fields values are not <a href="https://stackoverflow.com/a/35516532" target="_blank">skewed</a></td>
    </tr>
    <tr>
        <td>index.FindEntitiesByIndex(indexOperator)</td>
        <td>b-tree</td>
        <td>O(log n)</td>
        <td>if index field data is not <a href="https://stackoverflow.com/a/35516532" target="_blank">skewed</a></td>
    </tr>
    <tr>
        <td>meta.FindEntity(predicate), meta.FindEntities(predicate)</td>
        <td>no</td>
        <td>O(n), fullscan</td>
        <td></td>
    </tr>
</table>

<h6>Keys</h6>
<p>
    Following fields can be added to a key: bool, int, long, decimal, bool?, int?, long?, string, text, enum, relationSingle.
</p>
<p>
    You can access the matching row(s) directly without searching, using BGKey class or <a href="../CodeGeneration/ExtensionClasses#whatIsGenerated">generated methods</a>.
    To access the key use BGMetaEntity.GetKey({keyName}) method.
</p>
<p>
    Keys make row(s) access faster, but uses extra memory and may slow down write (update) operations, so do not use keys for data, which is updated frequently.
</p>
<div class="bg-image">
    <a href="#path images/Blog/Blog14.png"><img style="width: 400px" src="#path images/Blog/Blog14.png"></a>
</div>

<h6>Indexes</h6>
<p>
    Currently only single field index is supported.
    Indexes enables row(s) range scan fast operations, but uses extra memory and may slow down write (update) operations.
    To access the index use BGMetaEntity.GetIndex({indexName}) method or use <a href="../CodeGeneration/ExtensionClasses#whatIsGenerated">generated methods</a>.
</p>

<h4 id="commandline">Command Line</h4>
<p>
    Command line utility (Settings->Command line) let you run DDL-like commands with simplified syntax.
</p>
<p>
    Syntax is (use empty line to separate commands):
</p>
<pre>
    COMMAND [Options]
    [Additional options]
</pre>
<p>
    Available commands:
</p>
<ol>
    <li>CREATE TABLE [TableName]<br>
        [FieldName] [FieldType]
    </li>
    <li>ALTER TABLE [TableName]<br>
        ADD [FieldName] [FieldType]<br>
        DROP [FieldName]
    </li>
    <li>DROP TABLE [TableName]</li>
</ol>
<p>
    Example:
</p>
<pre>
    CREATE TABLE MyTable
    MyField1 int
    MyField2 bool

    ALTER TABLE MyTable
    ADD MyField3 int
    DROP MyField1

    DROP TABLE MyTable
</pre>

<h4 id="customFields">Custom fields implementation guide</h4>
<ol>
    <li>Do not use custom fields unless all other alternatives are much worse.
        For example, if your custom field has two properties (int and float) there is no need to create a custom field,
        you can use two basic fields instead (int and float) to store the values.
    </li>
    <li>
        Do not try to create your custom field in your actual project.
        Create and test your custom field using a new, empty project.
        Make sure it works correctly before transferring this field to your project.
        A bug in your implementation can break the whole database
    </li>
    <li>
        Use existing fields implementations as examples.
        Fields implementation sources can be found in Assets\BansheeGz\BGDatabase\Scripts\BGDatabaseSourceCode.unitypackage package (Database\Field\*).
        Fields managers implementation sources can be found in Assets\BansheeGz\BGDatabase\Editor\Scripts\BGDatabaseEditorSourceCode.unitypackage package (Database\Field\*).
    </li>
    <li>
        To create a custom field you need to create two C# classes:
        <ol>
            <li>Class for the field (in runtime assembly)</li>
            <li>Class for the field's manager (in Editor assembly)</li>
        </ol>
    </li>
    <li>
        [Important] Do not try to create your classes from scratch, extend them from existing classes.<br/>
        For your field class:
        <ol>
            <li>If your field value is a class extend your field class from BGFieldCachedClassA class</li>
            <li>If your field value is a struct extend your field class from BGFieldCachedStructA class</li>
        </ol>
        For your field's manager class:
        <ol>
            <li>If your field value can be edited "in place" (like primitive fields: int, float, string)- extend your field's manager class from BGFieldManagerInlinedA class</li>
            <li>If your field value can be edited in popup window, which can be opened by clicking on cell button
                (like complex fields: bounds, assets)- extend your field's manager class from BGFieldManagerWithButtonA class</li>
        </ol>
    </li>
    <li>
        The methods/properties, which need to be implemented for your field class:
        <ol>
            <li>ToBytes/FromBytes- for binary serialization</li>
            <li>ToString/FromString- for string serialization</li>
            <li>CreateFieldFactory- utility method for creating new fields</li>
            <li>Implement ICloneable interface for your value type if it's a class (not struct)</li>
            <li>ValueSize property if your value type is a struct</li>
        </ol>
    </li>
    <li>
        If you have difficulties implementing your own custom field- contact us and send us full source code for your value type (class/struct).
        You can skip its methods but all fields which needs to be saved inside database need to be included.
    </li>
</ol>
