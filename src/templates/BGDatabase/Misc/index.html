#set page=Misc

<h4>Table of content</h4>
<div>
    <ol>
        <li><a href="#events">Events</a></li>
        <li><a href="#validation">Validation</a></li>
        <li><a href="#keys">Custom keys</a></li>
        <li><a href="#commandline">Command line</a></li>
        <li><a href="#customFields">Custom fields</a></li>
    </ol>
</div>

<h4 id="events">Events</h4>

<p>
    Events let use listen to database changes, like changing the field or entity, adding or removing entities.
</p>

<h6>How to use?</h6>

<p>
    Add your listeners, like this
</p>
<pre class="nomargin"><code class="language-csharp">
    private void AddListeners()
    {
        var events = BGRepo.I.Events;

        //listen to particular entity (row)
        events.AddEntityUpdatedListener(new BGId("some-entity-id"), EntityUpdated);
        events.AddEntityDeletedListener(new BGId("some-entity-id"), EntityDeleted);

        //listen to all entities (rows)
        events.AddAnyEntityAddedListener(new BGId("some-meta-id"), SomeEntityAdded);
        events.AddAnyEntityDeletedListener(new BGId("some-meta-id"), SomeEntityDeleted);
        events.AddAnyEntityUpdatedListener(new BGId("some-meta-id"), SomeEntityUpdated);

        //listen to some field change
        events.AddFieldListener(new BGId("some-field-id"), FieldChanged);
    }

    //------------------------------------------------
    //            Field changed
    //------------------------------------------------
    private void FieldChanged(object sender, BGEventArgsField e)
    {
        Debug.Log("The Field is changed " + e.Entity.Name);
    }

    //------------------------------------------------
    //             any entity (row)
    //------------------------------------------------
    private void SomeEntityUpdated(object sender, BGEventArgsAnyEntityUpdated e)
    {
        Debug.Log("Some Entity Updated " + e.Entity.Name);
    }

    private void SomeEntityDeleted(object sender, BGEventArgsAnyEntity e)
    {
        Debug.Log("Some Entity Deleted " + e.Entity.Id);
    }

    private void SomeEntityAdded(object sender, BGEventArgsAnyEntity e)
    {
        //note, fields are not available here
        Debug.Log("Some Entity Added " + e.Entity.Id);
    }

    //------------------------------------------------
    //             particular entity (row)
    //------------------------------------------------
    private void EntityDeleted(object sender, BGEventArgsEntity e)
    {
        Debug.Log("The Entity Deleted " + e.Entity.Id);
    }

    private void EntityUpdated(object sender, BGEventArgsEntityUpdated e)
    {
        Debug.Log("The Entity Updated " + e.Entity.Name);
    }
</code></pre>

<p>
    Do not forget to remove listeners, as soon as they are not needed.
    For example in you MonoBehaviour classes, use OnDestroy method to remove listeners.
</p>
<p>
    Use corresponding events.RemoveXXX method to remove a listener.
</p>



<h4 id="validation">Validation</h4>

<p>
    Data validation allows to set the rules to validate data.
    Validation works in Unity Editor only and has no effect at runtime.
    To turn on validation, press on "Validation off" button at the top left of BGDatabase window.
</p>

<h6>Validation types</h6>
<ol>
    <li><a href="#data">Database data validation</a></li>
    <li><a href="#scene">Scene objects validation</a> (Binders and BGEntityGo components)</li>
</ol>

<h6 id="data">Database data validation</h6>
<table class="contentTable">
    <tr>
        <th>
            Validation rule
        </th>
        <th>
            Description
        </th>
    </tr>
    <tr>
        <td>Entity name is unique</td>
        <td>If entity has a name, it should be unique</td>
    </tr>
    <tr>
        <td>Entity name is empty</td>
        <td>Entities should have no name (names can be cleared under Configuration tab)</td>
    </tr>
    <tr>
        <td>Entity is singleton</td>
        <td>Only one single entity should exist</td>
    </tr>
    <tr>
        <td>Field is required</td>
        <td>Field should have some value. Only class-based fields are affected, cause struct-based fields always have a value</td>
    </tr>
    <tr>
        <td>Key is unique</td>
        <td>Each <a href="#keys">key</a>, marked as unique, should have 0-1 matching rows. If there are more than 1 matching row, it's considered to be a rule violation.</td>
    </tr>
</table>
<p>
    To review validation log, hover over red E icons as shown on the screenshot below.
    E icon is shown only if at least one error exists.
</p>
<div class="bg-image">
    <a href="#path images/BGDatabase/Validation1.png"><img style="width: 400px" src="#path images/BGDatabase/Validation1.png"></a>
</div>

<h6  id="scene">Scene objects validation</h6>
<p>
    Following BGDatabase scene components can also be validated (using Scene Explorer tab).
</p>
<ol>
    <li>BGEntityGo components</li>
    <li>Generated Monobehaviour classes (extending from BGEntityGo)</li>
    <li><a href="../DataBinding">Data binders</a></li>
</ol>
<p>
    Any component, which has an error, will be highlighted.
</p>


<h4 id="keys">Custom keys</h4>
<p>
    Custom key is a user defined key, which can be used to read row(s) quickly.
    It also can be used in rows <a href="#validation">validation</a>
</p>
<p>
    Each key consist of 1-n fields and can be marked as unique. Following fields can be added to a key: bool, int, long, decimal, bool?, int?, long?, string, text, enum, relationSingle.
</p>
<p>
    You can access the matching row(s) directly without searching, using BGKey class or generated methods.
    To access the key use BGMetaEntity.GetKey({keyName}) method.
</p>
<p>
    Keys make row(s) access faster, but uses extra memory and may slow down write (update) operations significantly, so do not use keys for data, which is updated frequently.
</p>
<div class="bg-image">
    <a href="#path images/Blog/Blog14.png"><img style="width: 400px" src="#path images/Blog/Blog14.png"></a>
</div>


<h4 id="commandline">Command Line</h4>
<p>
    Command line utility (Settings->Command line) let you run DDL-like commands with simplified syntax.
</p>
<p>
    Syntax is (use empty line to separate commands):
</p>
<pre>
    COMMAND [Options]
    [Additional options]
</pre>
<p>
    Available commands:
</p>
<ol>
    <li>CREATE TABLE [TableName]<br>
        [FieldName] [FieldType]
    </li>
    <li>ALTER TABLE [TableName]<br>
        ADD [FieldName] [FieldType]<br>
        DROP [FieldName]
    </li>
    <li>DROP TABLE [TableName]</li>
</ol>
<p>
    Example:
</p>
<pre>
    CREATE TABLE MyTable
    MyField1 int
    MyField2 bool

    ALTER TABLE MyTable
    ADD MyField3 int
    DROP MyField1

    DROP TABLE MyTable
</pre>

<h4 id="customFields">Custom fields implementation guide</h4>
<ol>
    <li>Do not use custom fields unless all other alternatives are much worse.
        For example, if your custom field has two properties (int and float) there is no need to create a custom field,
        you can use two basic fields instead (int and float) to store the values.
    </li>
    <li>
        Do not try to create your custom field in your actual project.
        Create and test your custom field using a new, empty project.
        Make sure it works correctly before transferring this field to your project.
        A bug in your implementation can break the whole database
    </li>
    <li>
        Use existing fields implementations as examples.
        Fields implementation sources can be found in Assets\BansheeGz\BGDatabase\Scripts\BGDatabaseSourceCode.unitypackage package (Database\Field\*).
        Fields managers implementation sources can be found in Assets\BansheeGz\BGDatabase\Editor\Scripts\BGDatabaseEditorSourceCode.unitypackage package (Database\Field\*).
    </li>
    <li>
        To create a custom field you need to create two C# classes:
        <ol>
            <li>Class for the field (in runtime assembly)</li>
            <li>Class for the field's manager (in Editor assembly)</li>
        </ol>
    </li>
    <li>
        [Important] Do not try to create your classes from scratch, extend them from existing classes.<br/>
        For your field class:
        <ol>
            <li>If your field value is a class extend your field class from BGFieldCachedClassA class</li>
            <li>If your field value is a struct extend your field class from BGFieldCachedStructA class</li>
        </ol>
        For your field's manager class:
        <ol>
            <li>If your field value can be edited "in place" (like primitive fields: int, float, string)- extend your field's manager class from BGFieldManagerInlinedA class</li>
            <li>If your field value can be edited in popup window, which can be opened by clicking on cell button
                (like complex fields: bounds, assets)- extend your field's manager class from BGFieldManagerWithButtonA class</li>
        </ol>
    </li>
    <li>
        The methods/properties, which need to be implemented for your field class:
        <ol>
            <li>ToBytes/FromBytes- for binary serialization</li>
            <li>ToString/FromString- for string serialization</li>
            <li>CreateFieldFactory- utility method for creating new fields</li>
            <li>Implement ICloneable interface for your value type if it's a class (not struct)</li>
            <li>ValueSize property if your value type is a struct</li>
        </ol>
    </li>
    <li>
        If you have difficulties implementing your own custom field- contact us and send us full source code for your value type (class/struct).
        You can skip its methods but all fields which needs to be saved inside database need to be included.
    </li>
</ol>
