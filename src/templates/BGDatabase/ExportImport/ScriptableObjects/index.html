#set page=Export Import
#set subPage=Scriptable objects

<h4>Description</h4>
<p>
    Generate both scriptable object C# sources (one per table) and assets
    (one per row or inlined <a href="https://learn.microsoft.com/en-us/dotnet/api/system.serializableattribute?view=net-9.0">Serializable</a> objects).
</p>

<h4>Setup</h4>
<ol>
    <li>Read <a href="../Common">this guide</a> to learn how to create a data source and a job</li>
    <li>Switch to a data source and select a folder for C# source files for scriptable objects (use new, empty folder)
        and press on "Generate C# source files" button to generate C# sources for scriptable objects.
        One C# source file for each table will be generated.
        <div class="bg-image">
            <a href="#path images/BGDatabase/SO3.png"><img style="width: 400px" src="#path images/BGDatabase/SO3.png"></a>
        </div>
    </li>
    <li>Select a folder for scriptable object assets (use new, empty folder)</li>
    <li>Switch to a job and setup <a href="../MergeSettings">merge settings</a>.
        Be careful with "Remove orphaned" setting, because it can lead to rows or assets being deleted if no matching row or asset is found.
    </li>
    <li>
        Click on "Export" button to generate assets or "Import" button to transfer data from assets to database
        <div class="bg-image">
            <a href="#path images/BGDatabase/SO4.png"><img style="width: 400px" src="#path images/BGDatabase/SO4.png"></a>
        </div>
    </li>
</ol>

<h4>Limitations and warnings</h4>
<ol>
    <li>
        With <a href="#inlining">inline config</a> and <a href="#processor">custom field processors</a>, introduced in BGDatabase version 1.9.3,
        we believe that almost any scriptable object can be mapped to the database structure.
        <details>
            <summary>Archived warning</summary>
            Data exchange with scriptable objects is not universal.
            If scriptable assets are created with our generated C# classes, it's possible to export/import any data
            from/to the database (as soon as <a href="#unsupported">the fields are supported</a>).
            However, if scriptable assets are not created with our generated C# classes,
            there may be a chance that you will not be able to export/import data from such scriptable assets into the database.
        </details>
    </li>
    <li>Select 2 new, empty folders for generated C# sources and scriptable assets. Do not put other assets in these folders.
    </li>
    <li>Exporting data while assets are not yet exist is very slow, exporting 1000 rows can take 20-25 seconds.
        Transferring data to existing assets or importing data is quite fast.
    </li>
    <li>Exporting data creates one asset(file) per each row, keep this in mind if you have a lot of rows</li>
    <li>If you want to create a new asset and import it later to the database by duplicating existing asset,
        make sure to clear <code>Id</code> field in duplicated asset, otherwise the asset will be ignored
    </li>
    <li>Though <a href="../MergeSettings">merge settings</a> are supported,
        we recommend to use data source settings to include/exclude tables/fields instead
    </li>
<!--
    <li>While importing (ScriptableObjects->database) is fast, exporting (database->ScriptableObjects) is very slow,
        even exporting 1000 rows can be very slow
    </li>
-->
    <li>When you use "Remove orphaned" toggle in <a href="../../ExportImport/MergeSettings">merge settings</a> during export,
        it means that orphaned scriptable assets will be physically deleted.
    </li>
    <li>See the job's log for more information about synchronization process</li>
    <li>Not all fields are supported (read the section below for more details).</li>
    <li>Read the guide below about how to change settings or table/field names safely</li>
</ol>

<h4>C# sources and assets</h4>
<p>
    Scriptable objects consist of two parts- C# source files for scriptable objects (with cs extension),
    which defines which fields each asset has and the assets, the instances of this C# class, stored in separate files (with asset extension).
    Both C# source files (one for each table) and the assets/inlined objects (one for each row) are generated.
</p>
<ol>
    <li>Generating C# sources: C# sources can be generated from data source page. You can also exclude some
        tables/fields from generation. If you want to add your own fields/methods to generated classes,
        read <a href="../../Misc/AddingMembersToGeneratedClasses">this guide</a>.
    </li>
    <li>Generating assets: assets are generated during export job execution.
        C# source files should be up-to-date,
        they should have all supported/included database fields, otherwise exception is thrown
        and C# source files generation should be run to update source files.
    </li>
</ol>

<h4 id="unsupported">Unsupported fields</h4>
<p>
    Most of the fields, including assets and relations are supported.
    The following fields are excluded because they are not supported by Unity (hashtable, guid, ray, ray2D, listGuid, decimal, all nullable fields).
    The following fields rely on BGDatabase code and are also excluded (objectReference, objectListReference,
    objectListMultiValueReference, entityReference, entityReferenceList, id, action).
    If you exclude some table manually, all relational fields, referencing this table, are going to be excluded automatically.
</p>

<h4>How to change settings, table/field names</h4>
<p>
    If you change folders, class name prefix or table name without any further action, you are going to lose the link between database data and
    existing assets or create duplicates next time you export/import data.
    This section describes, how to update folders, class name prefix, table or field names without losing links with existing assets.
    [Important] Backup your project just in case before renaming
</p>
<h5>Changing folders</h5>
<p>
    After changing folders in the settings, move the folders manually inside Unity Editor to new location.
</p>

<h5>Changing classes name prefix</h5>
<p>
    After changing <code>Classes name prefix</code> in the settings, rename all generated C# source files inside Unity Editor to reflect the change,
    for example if your source file is <code>S_MyTable.cs</code>, and you change the prefix from <code>S_</code> to <code>T_</code> the new name should be
    <code>T_MyTable.cs</code>. After changing all file names, regenerate C# sources for scriptable objects and fix all compilation errors
    by changing class names from old name (<code>S_MyTable</code>) to new name (<code>T_MyTable</code>) in your C# code.
</p>

<h5>Renaming table name</h5>
<p>
    After renaming table name, rename both the C# source file name and folder name for generated assets inside Unity Editor to reflect the change.
    For example, if the old name is <code>MyTable</code> and the new table name is <code>MyTableUpdated</code> and <code>Classes name prefix</code> is <code>S_</code>,
    rename C# source file from <code>S_MyTable.cs</code> to <code>S_MyTableUpdated.cs</code> and folder name from <code>MyTable</code> to <code>MyTableUpdated</code>.
    After changing C# file name and folder name, regenerate C# sources for scriptable objects and fix all compilation errors
    by changing class name from old name (<code>S_MyTable</code>) to new name (<code>S_MyTableUpdated</code>) in your C# code.
</p>

<h5>Renaming field name</h5>
<p>
    if you want to change field name and then re-generate both C# sources and the assets, there is no need for extra actions.
    If you want to rename the field and regenerate C# sources without re-generating the assets,
    you need to add
    <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Serialization.FormerlySerializedAsAttribute.html">FormerlySerializedAs</a>
    attribute to the C# field with value, equal to the old name. After renaming database field, open data source page, then "C# settings",
    then create a custom settings for the table, include the table, open fields popup, create a custom setting for the field, include it and enter old field name to
    "FormerlySerializedAs" column. You can remove this setting after assets generating is executed.
</p>
<img src="#path images/BGDatabase/SO2.png"/>

<h4 id="inlining">Inlining objects</h4>
<p class="importantNote">
    If you already use export/import with ScriptableObjects, back up your project before experimenting with object inlining.
    Classes generated with object inlining are not compatible with classes generated without it.
    If you switch from a ScriptableObject to a plain [Serializable] class, any existing assets created from that ScriptableObject will no longer be valid.
</p>
<p>Inlining stores entities (rows) inside their parent objects.
    When a meta is inlined, its class is a regular serializable class, not a ScriptableObject.
    Instead of creating a separate ScriptableObject asset for each row, rows are stored inline within the parent asset or object.
    The parent object is determined by a relationSingle field, each child row references its parent row.
</p>
<p>
    Example: suppose we have two tables, Countries and Cities.
    Each City row references a Country row. If City rows are inlined within Country rows,
</p>
<img src="#path images/BGDatabase/SO5.png"/>
<p>
    the City class becomes a regular serializable C# class, and the Country ScriptableObject contains a list of inlined cities.
</p>
<img src="#path images/BGDatabase/SO6.png"/>
<p>
    How it appears in the Unity Inspector
</p>
<img src="#path images/BGDatabase/SO7.png"/>
<p>
    You can also inline a single entity instead of a list.
    In that case, ensure each child row references exactly one parent row and each parent row is referenced by exactly one child row, forming a 1:1 relation.
    During data export, this requirement is checked and an error is thrown if it's violated
</p>
<img src="#path images/BGDatabase/SO8.png"/>

<p>
Two restrictions on inlining entities:
</p>
<ol>
    <li>No direct references: You cannot reference an inlined object directly from scripts, access is only via its parent object.</li>
    <li>No incoming relations: Inlined entities must not have incoming relations, except for relations from other meta rows that are also inlined.</li>
</ol>

<h5 id="processor">Customizing individual fields</h5>
<p>
    You can customize export, import, and code generation for individual fields using C#.
    Create a class that inherits from BGSOFieldProcessor and place it in an Editor folder.
    BGSOFieldProcessor provides four methods you can override to control how a field is processed.
</p>
<ol>
    <li>IsApplicableTo: activates your processor for a particular field.</li>
    <li>OnCodeGeneration: customize the generated C# field name and type.</li>
    <li>OnEntityExport: transfer the value from the database to the ScriptableObject.</li>
    <li>OnEntityImport: transfer the value from the ScriptableObject back to the database.</li>
</ol>
Here is example code, which transform database "stringList" field with type List&lt;string&gt; to ScriptableObject's "intList" C# field with type List&lt;int&gt;

<details>
    <summary>Example code</summary>
<pre class="nomargin"><code class="language-csharp">
using System.Collections.Generic;
using System.Linq;
using BansheeGz.BGDatabase;
using BansheeGz.BGDatabase.Editor;

//custom processor for converting DB Test.stringList field with List&lt;string&gt; type
//to scriptableObject intList with List&lt;int&gt; type
public class SOStringListToIntList : BGSOFieldProcessor
{
    //activates this processor for Test.stringList field
    public override bool IsApplicableTo(IsApplicableToRequest request) => request.Field.FullName == "Test.stringList";

    //adds C# field with "intList" name and List&lt;int&gt; type to the generated C# class instead of "stringList"
    public override void OnCodeGeneration(OnCodeGenerationRequest request) =>
        request.ClassBuilder.Add(new BGCodeGenClass.Field
        {
            Name = "intList",
            Type = "System.Collections.Generic.List&lt;int&gt;",
            IsPublic = true,
        });

    //copy value from the database row to the scriptable object (executed on export)
    public override void OnEntityExport(OnEntityExportRequest request)
    {
        //S_Test is the name of the scriptable object C# class
        var scriptableObject = (S_Test)request.Asset;
        //downcast field to the target type
        var stringListField = (BGFieldListStringContract) request.Field;
        //get db value
        List&lt;string&gt; dbList = stringListField[request.Entity];
        //convert the list of strings to the list of ints
        List&lt;int&gt; intList = dbList?.Select(int.Parse).ToList();
        // scriptableObject.intList field should be generated in OnCodeGeneration method
        scriptableObject.intList = intList;
    }

    //copy value from the scriptable object to the database row (executed on import)
    public override void OnEntityImport(OnEntityImportRequest request)
    {
        //S_Test is the name of the scriptable object C# class
        var scriptableObject = (S_Test)request.Asset;
        //downcast field to the target type
        var stringListField = (BGFieldListStringContract) request.Field;
        //get SO value (intList should be generated in OnCodeGeneration method)
        List&lt;int&gt; intList =  scriptableObject.intList;
        //convert the list of ints to the list of strings
        List&lt;string&gt; dbList = intList?.Select(value => value.ToString()).ToList();
        // set database value
        stringListField[request.Entity] = dbList;
    }
}
</code></pre>
</details>