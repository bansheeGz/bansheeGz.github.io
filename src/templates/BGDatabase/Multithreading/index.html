#set page=Multithreading

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=cs&amp;skin=desert"></script>


<h4>Overview</h4>
<p>
	BGDatabase itself is not thread-safe, it's meant to be called from main thread only (from MonoBehaviour scripts)
</p>
<p>
	However there are 2 scenarios, you could use BGDatabase in multi-threaded environment (for example, with Unity ECS).
</p>
<ol>
	<li>Use data from BGDatabase and create Unity ECS entities. Merge changes back to database on save if needed.</li>
	<li>Use multi-threaded add-on (currently in Beta)</li>
</ol>

<h4>Scenario # 1 </h4>
<ol>
	<li>Make sure you call database only from main thread (e.g. from MonoBehaviour classes)</li>
	<li>Create Unity ECS entities out of database information from MonoBehaviour class</li>
	<li>If you need some of these Unity ECS entities to be persistent, (e.g. they needs to be saved/loaded),
		store them back to database the moment they needs to be persisted, e.g, when the game needs to be saved.
		Run saving/loading on main thread.
	</li>
	<li>
		If you need to call database from multithreaded environment, use <code>BGMainThreadRunner.RunOnMainThread(Action action)</code>.
		This will add action to the jobs list to be run on main thread.
		Make sure you call at sparingly, at some relatively rare condition, otherwise it can become a bottleneck.
	</li>
</ol>

<h4>Scenario # 2 (MT addon overview)</h4>
<div class="importantNote">
	MT add-on is currently in Beta, available for review. This page is also work-in-progress.
</div>

<p>
	Use <a href="../Addons/Multithreading">multi-threading addon</a> (MT addon) (currently in Beta).
	Multi-threading addon creates environment, which can be accessed from multiple threads safely,
	by coping chosen tables data into special data containers.
</p>

<h4>Scenario # 2 (How MT addon works?)</h4>
<div class="bg-image">
	<a href="#path images/BGDatabase/MTAddonReview.png"><img style="width: 400px" src="#path images/BGDatabase/MTAddonReview.png"></a>
</div>

<h4>Scenario # 2 (What can I do with MT addon?)</h4>
<ol>
	<li>You can chose which tables you want to be accessible for multi-threading operations.</li>
	<li>You can merge changes back to main database either manually or auto (on saving).
		Otherwise changes are not synchronized.
		Merging changes back is pretty expensive operation.
	</li>
	<li>MT addon has it's own code generator and API very similar to single-threaded API.</li>
	<li>There are 2 types of transactions: lightweight, lock-free readonly transactions and very heavy write transactions.
		If you need to update data very often, please, consider scenario # 1 instead.
	</li>
</ol>

<h4>Scenario # 2 (What I need to know before using MT Addon?)</h4>
<ol>
	<li>Lists fields, Unity assets fields and fields, which reference Unity objects are not supported.</li>
	<li>All entities are structs, not classes. If result can be null, BGMTEntity? is used</li>
	<li>Entities are only marked as deleted inside transaction, the actual removal takes place at the end of transaction</li>
	<li>Write transactions can be executed asynchronously, so do not expect changes take effect right after the method call.
		If you need some code to be run after transaction finish, use (Action callback) as second parameter to BGRepo.M.Write method</li>
</ol>

<h4>Scenario # 2 (How to use MT addon?)</h4>
<p>
	We tried our best to make multithreaded API very similar to single-threaded one. Also, we provide code generation for MT addon.
</p>
<pre class="prettyprint">
        //start read-only transaction (option 1)
        BGMTRepo mtRepo = BGRepo.M.RepoReadOnly;

	    //start read-only transaction (option 2)
	    BGRepo.M.Read(mtRepo =>
        {
            //access data here
        });

	    //start write transaction (the only option)
	    BGRepo.M.Write(mtRepo =>
        {
            // you can read and change data here.
			// This transaction can be run asynchronously (on separate thread),
			// so do not expect changes take effect right after the method call
        });
</pre>
<p>
	BGMTRepo has very similar methods to ones single-threaded API has.
	For example, to iterate through "Items" table rows, which have "damage" column value more than 10:
</p>
<pre class="prettyprint">
        BGRepo.M.Read(mtRepo =>
        {
            mtRepo["Items"].ForEachEntity(entity =>
            {
                print("Weapon: " + entity.Name);
            }, entity => entity.Get&lt;int&gt;("damage") > 10);
        });
</pre>
<p>
	And just like with single-threaded API, Code generation greatly simplify access to database by removing all boilerplate code
</p>
<pre class="prettyprint">
		BGRepo.M.Read(mtRepo =>
		{
			Items.ForEachEntity(mtRepo, item =>
			{
				print("Weapon: " + item.name);
			}, item => item.damage > 10);
		});
</pre>

